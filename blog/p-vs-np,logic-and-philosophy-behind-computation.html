<!DOCTYPE html><html lang="en"><head><link rel="preload" href="/fonts/inter-var-latin.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link href="/static/favicons/favicon.ico" rel="shortcut icon"/><link href="/static/favicons/site.webmanifest" rel="manifest"/><link rel="preconnect" href="https://cdn.usefathom.com" crossorigin=""/><link href="/static/favicons/apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180"/><link href="/static/favicons/favicon-32x32.png" rel="icon" sizes="32x32" type="image/png"/><link href="/static/favicons/favicon-16x16.png" rel="icon" sizes="16x16" type="image/png"/><link color="#4a9885" href="/static/favicons/safari-pinned-tab.svg" rel="mask-icon"/><meta content="#ffffff" name="theme-color"/><meta content="#ffffff" name="msapplication-TileColor"/><meta content="/static/favicons/browserconfig.xml" name="msapplication-config"/><meta content="14d2e73487fa6c71" name="yandex-verification"/><meta content="eZSdmzAXlLkKhNJzfgwDqWORghxnJ8qR9_CHdAh5-xw" name="google-site-verification"/><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><script>!function(){try {var d=document.documentElement.classList;d.remove('light','dark');var e=localStorage.getItem('theme');if("system"===e||(!e&&true)){var t="(prefers-color-scheme: dark)",m=window.matchMedia(t);m.media!==t||m.matches?d.add('dark'):d.add('light')}else if(e) d.add(e)}catch(e){}}()</script><title>P vs NP, Logic and Philosophy Behind Computation – Pranav Kumar Pulusu</title><meta name="robots" content="follow, index"/><meta content="Intuition and foundational philosophy of computation" name="description"/><meta property="og:url" content="https://kumaarpranv.github.io/blog/p-vs-np%2Clogic-and-philosophy-behind-computation"/><link rel="canonical" href="https://kumaarpranv.github.io/blog/p-vs-np%2Clogic-and-philosophy-behind-computation"/><meta property="og:type" content="article"/><meta property="og:site_name" content="Pranav kumar"/><meta property="og:description" content="Intuition and foundational philosophy of computation"/><meta property="og:title" content="P vs NP, Logic and Philosophy Behind Computation – Pranav Kumar Pulusu"/><meta property="og:image" content="https://kumaarpranv.github.io/static/images/pvsnp-intro/banner.png"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@amateurtheorist"/><meta name="twitter:title" content="P vs NP, Logic and Philosophy Behind Computation – Pranav Kumar Pulusu"/><meta name="twitter:description" content="Intuition and foundational philosophy of computation"/><meta name="twitter:image" content="https://kumaarpranv.github.io/static/images/pvsnp-intro/banner.png"/><meta property="article:published_time" content="2021-06-18T00:00:00.000Z"/><meta name="next-head-count" content="19"/><link rel="preload" href="/_next/static/css/a4a73b1666999a74c447.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a4a73b1666999a74c447.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/webpack-189c53927ffd3caf09c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/main-b53ad54fde926f8ee4c7.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-d9d931a11f6f217e030b.js" as="script"/><link rel="preload" href="/_next/static/chunks/562-cf4ef120cfac2df7f9ea.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bslug%5D-a7fcfddf24d7867ca73a.js" as="script"/></head><body class="bg-white dark:bg-black text-white dark:text-black"><div id="__next"><div class="bg-white dark:bg-black"><nav class="flex items-center justify-between w-full max-w-4xl p-8 mx-auto my-0 text-gray-900 bg-white sticky-nav md:my-8 dark:bg-black bg-opacity-60 dark:text-gray-100"><a href="#skip" class="skip-nav">Skip to content</a><button aria-label="Toggle Dark Mode" type="button" class="w-10 h-10 p-3 bg-gray-200 rounded dark:bg-gray-800"></button><div><a class="p-1 text-gray-900 sm:p-4 dark:text-gray-100" href="/">Home</a><a class="p-1 text-gray-900 sm:p-4 dark:text-gray-100" href="/about">About</a><a class="p-1 text-gray-900 sm:p-4 dark:text-gray-100" href="/blog">Blog</a><a class="p-1 text-gray-900 sm:p-4 dark:text-gray-100" href="/resourcelist">Resource List</a></div></nav><main id="skip" class="flex flex-col justify-center px-8 bg-white dark:bg-black"><article class="flex flex-col justify-center items-start max-w-2xl mx-auto mb-16 w-full"><h1 class="font-bold text-3xl md:text-5xl tracking-tight mb-4 text-black dark:text-white">P vs NP, Logic and Philosophy Behind Computation</h1><div class="flex flex-col md:flex-row justify-between items-start md:items-center w-full mt-2"><div class="flex items-center"><img alt="Pranav Kumar" height="24" width="24" src="/avatar.png" class="rounded-full"/><p class="text-sm text-gray-700 dark:text-gray-300 ml-2">Pranav kumar Pulusu / <!-- -->June 18, 2021</p></div><p class="text-sm text-gray-500 min-w-32 mt-2 md:mt-0">10 min read<!-- --> • </p></div><div class="prose dark:prose-dark max-w-none w-full"><img alt="Banner" src="/static/images/pvsnp-intro/banner.png" width="1200" height="600"/><p>This is my First Article, Here I try to present Intuition and foundational philosophy of computation to CS and non-CS students alike. I try to make the theory as simple as possible but not simpler that takes the aesthetics away.  references are mentioned at footer. </p><h3 id="what-is-computation"><a href="#what-is-computation" class="anchor"><span class="icon icon-link"></span></a>What is computation?</h3><p>Computer science isn’t just limited to computers and electronic devices. Famous Computer Scientist Edsger Dijkstra once said, “computer science has as much to do with computers as astronomy has to do with telescopes”.  like the natural sciences, computer science also has a solid philosophical background. </p><p>quoting Scott Aaronson “computer science is a mathematical set of tools, or body of ideas, for understanding just about any system—brain, universe, living organism, or, yes, computer. ”</p><p>A Physicist seeks out “The rules of nature, with varying scale from subatomic to cosmic and often It happens by finding a general rule, and then they will try to find deeper rules that makes the general rule stable in a top-down approach”.</p><p>A Computer scientist seeks out “How hard is the system built by these rules? we typically take stable simple systems and try to form more complex systems in a bottom-up approach”. There is also a fundamental question that drives a computer scientist, “why some problems are Harder than others?” and we try to look for mathematical structures, logical models that helps us in interpreting the problems and try to solve them (or) gain Intuition along the way.</p><p>But what is Hardness? we had to give a metric to classify some problems as hard while others as relatively simple and also is every problem solvable?The answer to the second question is, “NO”. let’s try to formalize this, for that let’s have a brief about turing machine, “Turing machine is an abstract mathematical model that takes an input, performs some basic operations, writes output and halts (stops)”. computers are built with the notion of turing machine ( but not perfectly because computers have finite memory while turing machine is theorized to have infinite memory ) but any computer can be converted to a Turing machine. There are many variants of Turing machine but each of them can be converted to a deterministic Turing machine with more time penalty.</p><img alt="Turing machine to practical devices" src="/static/images/pvsnp-intro/tm-to-pc.png" width="1440" height="900"/><img alt="Different complexity realizations" src="/static/images/pvsnp-intro/complexity-practical.png" width="1440" height="900"/><p>So, As the turing machines are very powerful, we take turing machine as the computational model for computational theory and complexity theory.</p><p>To solve a problem, we take input perform operations and create an output. the set of all possible inputs of the problem is called a “language” mostly infinite. a language is called decidable, If a turing machine can output “Yes” or “No” and halt on every input from the language.</p><p>Tracing back, some problems are inherently Unsolvable ( Undecidable ), one such is the infamous Halting problem.Halting problem is an undecidable problem where given a turing machine description, input, we should determine whether the turing machine halts on that input. like a general algorithm that can determine whether a turing machine halts or goes into an infinite loop on an input. there is a nice proof to prove this via contradiction, but I’m not explaining it as it doesn’t help in our P vs NP quest.</p><p>So, Tracing back Answering the first question, we classify the problems by their factors like solvability, time requirement, space requirement, computational model.</p><p>Here, I need to specify the difference between a deterministic turing machine, non-deterministic turing machine. in essence, determinism here specifies being able to do only one operation at a time, in non-determinism you perform correct operation at every instant without searching through possibilities. in reality, non-deterministic machines aren’t possible. but as we said earlier, every non-deterministic turing machine can be converted into a deterministic turing machine with time penalty.</p><h3 id="complexity-classes"><a href="#complexity-classes" class="anchor"><span class="icon icon-link"></span></a>Complexity classes</h3><p>moving on,</p><p><strong>P</strong> is the set of all problems that can be solved in polynomial time ( at most <strong>N^k</strong>) on a deterministic turing machine where, N is the length of input, k is a constant.</p><p><strong>NP</strong> is the set of all problems that can be solved in polynomial time ( at most <strong>N^k</strong>) on a non-deterministic turing machine.</p><p>key thing to note here, is that every <strong>NP</strong> class problems can be solved in exponential time at most ( at most <strong>2^(N^k)</strong> ) time on a deterministic turing machine.</p><p><strong>EXPTIME</strong> is the set of all problems that can be solved in exponential time ( at most <strong>2^(N^k)</strong>) on a deterministic turing machine.so, <strong>NP</strong> ⊆ <strong>EXPTIME</strong> </p><p><strong>NP-complete</strong> is the set of <strong>NP</strong> problems which can be converted to every other <strong>NP</strong> problem can be in a polynomial time penalty. If we want to prove one <strong>NP</strong> problem as <strong>NP-complete</strong>, we need not to prove every <strong>NP</strong> problem being reduceable to that problem we can just prove that <strong>NP</strong> problem can reduced into <strong>NP-complete</strong>. Note that above, I used convertible, reduceable interchangeably.</p><p>the hierarchy,</p><img alt="P vs NP" src="/static/images/pvsnp-intro/pvsnp.png" width="1000" height="600"/><p>there are also, other complexity classes like <strong>NP-Hard</strong> ( problem set to which every <strong>NP</strong> problem can be reduced to whether <strong>NP</strong> or not ), <strong>PSPACE</strong> ( analogous to <strong>P</strong> in space ), <strong>NPSPACE</strong> ( analogous to <strong>NP</strong> in space ), before defined <strong>EXPTIME</strong> ( <strong>NP</strong> ⊆ <strong>EXPTIME</strong> ), <strong>NEXPTIME</strong> ( analogous to <strong>EXPTIME</strong> for <strong>NDTM</strong> ), etc. but we don’t need them to introduce <strong>P</strong> vs <strong>NP</strong>.</p><p>One Important thing to note, is even though <strong>NP</strong> problems require exponential time to solve, they require only polynomial time to be verified. i.e, we can think <strong>P</strong> class problems are easier to solve, easier to verify and <strong>NP</strong> problems are harder to solve but easier to verify. </p><p>Even though we aren’t able to prove <strong>P</strong> vs <strong>NP</strong> </p><p>But with time hierarchy theorem,  we proved that, <strong>P</strong> ⊊ <strong>EXPTIME</strong> ⊊ <strong>2-EXP</strong> ⊊ ... and <strong>NP</strong> ⊊ <strong>NEXPTIME</strong> ⊊ <strong>2-NEXP</strong> …</p><p>which can be helpful in solving <strong>P</strong> vs <strong>NP</strong>.</p><h3 id="p-vs-np--the-holy-grail-of-computer-science-"><a href="#p-vs-np--the-holy-grail-of-computer-science-" class="anchor"><span class="icon icon-link"></span></a>P vs NP ( the holy grail of computer science )</h3><p><strong>P</strong> vs <strong>NP</strong> is about figuring out whether <strong>P</strong> = <strong>NP</strong> or <strong>P</strong> ≠ <strong>NP</strong>. It’s is not just a mathematical problem but a philosophical one, “Is finding solutions harder than verifying them?” ( since <strong>P</strong> class problems can be solved easier, <strong>NP</strong> class problem are verified easier ).</p><p>we might think intuitively, “finding solutions is harder than verifying solutions” like “writing a great poem should be harder than checking a great poem”. Even the famous physicist Feynman had trouble even being convinced that <strong>P</strong> vs. <strong>NP</strong> was an open problem!</p><p>Because, All <strong>NP</strong> problems require brute-force search ( searching all possible states for solution ) which results in the exponential time requirement. So to believe <strong>P</strong> = <strong>NP</strong>, we need to assume there is a general efficient way to solve every <strong>NP</strong> problem. which is also a hard thing to assume against our Intuition.</p><p>we generally believe the conjecture that <strong>P</strong> ≠ <strong>NP</strong> but It’s very HARD to prove it!!</p><p>because, “A fundamental challenge when proving <strong>P</strong> ≠ <strong>NP</strong> is that, we have to separate <strong>NP</strong> problems that are actually HARD from the problems that just look HARD or used to be assumed HARD”. problems like primality testing, DNA sequencing which were assumed to be <strong>NP</strong> are now in <strong>P</strong>. the proofs that tried to prove, <strong>P</strong> ≠ <strong>NP</strong> can be rejected with this simple reason. as If we were to believe they work, then these polynomial reducible problems shouldn’t exist in the first place!</p><p>We can however reduce scope to make our proof more stable, here <strong>NP-complete</strong> comes into picture. remember that any <strong>NP-complete</strong> problem can be converted into any <strong>NP</strong> class problem. so, If we’re able to prove one <strong>NP-complete</strong> problem is equal to (or) not equal to <strong>P</strong>. we prove all problems of <strong>NP</strong> are equal to (or) not equal to <strong>NP</strong>.</p><p>Repercussions of proving <strong>P</strong> = <strong>NP</strong> are massive, If <strong>P</strong> = <strong>NP</strong> many other complexity classes fall into <strong>P</strong> as well like <strong>co-NP</strong>,  <strong>Πk P</strong>, <strong>Σk P</strong>.</p><p>with <strong>P</strong> = <strong>NP</strong>, </p><p>any reasonable length mathematical proof can be found efficiently by an algorithm! ( because even though in polynomial <strong>N^k</strong>, if the k is big It would be inefficient ). </p><p>the idea that such problem is in <strong>NP</strong> was actually pointed out by Kurt Godel in his 1956  letter to von neumann. he wrote, “Consider the problem of deciding whether a mathematical statement S has a proof in F with n symbols or fewer. we could always just program a computer to search through all <strong>2^n</strong> possible bit-strings with n symbols, and check whether any of them encodes a valid F-proof of S.”</p><p>Godel also pointed out, “it’s far from obvious how to prove that there isn’t a muchbetter approach: an approach that would avoid brute-force search, and find proofs of size n in time polynomial in n”. essentially discussing, proving <strong>P</strong> ≠ <strong>NP</strong> is HARD. the formal conjecture of <strong>P</strong> vs <strong>NP</strong> was formulated by cook in his 1971 paper.</p><p><strong>P</strong> = <strong>NP</strong> will also mean AI would be perfect as we can simply search large tree of possibilities in polynomial time. VLSI designers can design optimum circuits with minimum power requirements. any scientist can obtain the simplest theory that explains his/her experimental data, by Occam’s razor this is supposed to be the correct one! </p><p>as said earlier in summary, “Any problem whose solution that can be verified easily, can be produced approximately that much easily”.</p><p>It may also rule out the need of randomized algorithms, stochasticity principle as the gains will be negligible.</p><p>On the other hand, all our cryptographic algorithms are designed with the assumption of existence of one-way functions which in turn assumes <strong>P</strong> ≠ <strong>NP</strong>. so, there can be trivial decoding algorithms for every cryptographic algorithm, causing vulnerability to our security, privacy, data integrity.</p><p>so, this is the explanation I felt sufficient for intuitively understanding complexity. because, I saw even experienced people having confusion over these ( cough cough tutorialspoint guy ).</p><p>the main intention of writing this article, is to introduce these concepts intuitively to wider audience and to give motivation to CS students that they’re doing something really fundamental than just programming stuff. sadly, I was introduced to these concepts just before couple of months in my final year of Btech. had I been introduced to these earlier, It might’ve had significant impact in my formative years of undergraduation. which I hope happens to someone else. remember to get away from your engineering lens to a scientist lens once in a while. </p><p>an engineer will accept the rules they’re given and try to solve problems with those rules, a scientist will question the rules itself. a mechanical engineer may design machines without realizing that forces are illusion but a physicist would realize that. similarly, a software engineer will develop algorithms without realizing the underlying assumptions.</p><p>there are potential things that I missed (or) trivialized above for better understanding. as I’m fairly inexperienced, if there’re any errors above feel free to point out by my twitter handle. </p><h3 id="references"><a href="#references" class="anchor"><span class="icon icon-link"></span></a>References:</h3><ol><li>Introduction to the theory of computation - M Sipser</li><li>The history and status of P versus NP Question - M Sipser</li><li>Computational complexity a modern approach - S Arora, B Barak</li><li>The nature of computation - C Moore, S Mertens</li><li>What can be computed? - J MacCormick</li><li>Why Philosophers Should Care About Computational Complexity  - S Aaronson</li><li>Quantum computing since democritus - S Aaronson</li><li>Automata, Computability, and Complexity, MIT 2011 - S Aaronson</li></ol></div><div class="mt-8"></div><div class="text-sm text-gray-700 dark:text-gray-300"><a href="https://mobile.twitter.com/search?q=https%3A%2F%2Fkumaarpranv.github.io%2Fblog%2Fp-vs-np%2Clogic-and-philosophy-behind-computation" target="_blank" rel="noopener noreferrer">Discuss on Twitter</a> • <!-- -->Made with MDX js</div></article><footer class="flex flex-col justify-center items-start max-w-2xl mx-auto w-full mb-8"><hr class="w-full border-1 border-gray-200 dark:border-gray-800 mb-8"/><div class="w-full max-w-2xl grid grid-cols-1 gap-4 pb-16 sm:grid-cols-3"><div class="flex flex-col space-y-4"><a class="text-gray-500 hover:text-gray-600 transition" href="/">Home</a><a class="text-gray-500 hover:text-gray-600 transition" target="_blank" rel="noopener noreferrer" href="https://twitter.com/amateurtheorist">Twitter</a></div><div class="flex flex-col space-y-4"><a class="text-gray-500 hover:text-gray-600 transition" href="/about">About</a><a class="text-gray-500 hover:text-gray-600 transition" target="_blank" rel="noopener noreferrer" href="https://github.com/kumaarpranv">GitHub</a></div><div class="flex flex-col space-y-4"><a class="text-gray-500 hover:text-gray-600 transition" href="/blog">Blog</a><a class="text-gray-500 hover:text-gray-600 transition" target="_blank" rel="noopener noreferrer" href="https://linkedin.com/in/kumaarpranv">Linkedin</a></div></div></footer></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"mdxSource":{"compiledSource":"var h=Object.defineProperty,c=Object.defineProperties;var g=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;var p=(e,t,n)=\u003et in e?h(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,o=(e,t)=\u003e{for(var n in t||(t={}))s.call(t,n)\u0026\u0026p(e,n,t[n]);if(r)for(var n of r(t))i.call(t,n)\u0026\u0026p(e,n,t[n]);return e},m=(e,t)=\u003ec(e,g(t));var l=(e,t)=\u003e{var n={};for(var a in e)s.call(e,a)\u0026\u0026t.indexOf(a)\u003c0\u0026\u0026(n[a]=e[a]);if(e!=null\u0026\u0026r)for(var a of r(e))t.indexOf(a)\u003c0\u0026\u0026i.call(e,a)\u0026\u0026(n[a]=e[a]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var a=n,{components:e}=a,t=l(a,[\"components\"]);return mdx(MDXLayout,m(o(o({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"img\",{alt:\"Banner\",src:\"/static/images/pvsnp-intro/banner.png\",width:1200,height:600,priority:!0}),mdx(\"p\",null,\"This is my First Article, Here I try to present Intuition and foundational philosophy of computation to CS and non-CS students alike. I try to make the theory as simple as possible but not simpler that takes the aesthetics away.  references are mentioned at footer. \"),mdx(\"h3\",o({},{id:\"what-is-computation\"}),mdx(\"a\",o({parentName:\"h3\"},{href:\"#what-is-computation\",className:\"anchor\"}),mdx(\"span\",o({parentName:\"a\"},{className:\"icon icon-link\"}))),\"What is computation?\"),mdx(\"p\",null,\"Computer science isn\\u2019t just limited to computers and electronic devices. Famous Computer Scientist Edsger Dijkstra once said, \\u201Ccomputer science has as much to do with computers as astronomy has to do with telescopes\\u201D.  like the natural sciences, computer science also has a solid philosophical background. \"),mdx(\"p\",null,\"quoting Scott Aaronson \\u201Ccomputer science is a mathematical set of tools, or body of ideas, for understanding just about any system\\u2014brain, universe, living organism, or, yes, computer. \\u201D\"),mdx(\"p\",null,\"A Physicist seeks out \\u201CThe rules of nature, with varying scale from subatomic to cosmic and often It happens by finding a general rule, and then they will try to find deeper rules that makes the general rule stable in a top-down approach\\u201D.\"),mdx(\"p\",null,\"A Computer scientist seeks out \\u201CHow hard is the system built by these rules? we typically take stable simple systems and try to form more complex systems in a bottom-up approach\\u201D. There is also a fundamental question that drives a computer scientist, \\u201Cwhy some problems are Harder than others?\\u201D and we try to look for mathematical structures, logical models that helps us in interpreting the problems and try to solve them (or) gain Intuition along the way.\"),mdx(\"p\",null,\"But what is Hardness? we had to give a metric to classify some problems as hard while others as relatively simple and also is every problem solvable?The answer to the second question is, \\u201CNO\\u201D. let\\u2019s try to formalize this, for that let\\u2019s have a brief about turing machine, \\u201CTuring machine is an abstract mathematical model that takes an input, performs some basic operations, writes output and halts (stops)\\u201D. computers are built with the notion of turing machine ( but not perfectly because computers have finite memory while turing machine is theorized to have infinite memory ) but any computer can be converted to a Turing machine. There are many variants of Turing machine but each of them can be converted to a deterministic Turing machine with more time penalty.\"),mdx(\"img\",{alt:\"Turing machine to practical devices\",src:\"/static/images/pvsnp-intro/tm-to-pc.png\",width:1440,height:900}),mdx(\"img\",{alt:\"Different complexity realizations\",src:\"/static/images/pvsnp-intro/complexity-practical.png\",width:1440,height:900}),mdx(\"p\",null,\"So, As the turing machines are very powerful, we take turing machine as the computational model for computational theory and complexity theory.\"),mdx(\"p\",null,\"To solve a problem, we take input perform operations and create an output. the set of all possible inputs of the problem is called a \\u201Clanguage\\u201D mostly infinite. a language is called decidable, If a turing machine can output \\u201CYes\\u201D or \\u201CNo\\u201D and halt on every input from the language.\"),mdx(\"p\",null,\"Tracing back, some problems are inherently Unsolvable ( Undecidable ), one such is the infamous Halting problem.Halting problem is an undecidable problem where given a turing machine description, input, we should determine whether the turing machine halts on that input. like a general algorithm that can determine whether a turing machine halts or goes into an infinite loop on an input. there is a nice proof to prove this via contradiction, but I\\u2019m not explaining it as it doesn\\u2019t help in our P vs NP quest.\"),mdx(\"p\",null,\"So, Tracing back Answering the first question, we classify the problems by their factors like solvability, time requirement, space requirement, computational model.\"),mdx(\"p\",null,\"Here, I need to specify the difference between a deterministic turing machine, non-deterministic turing machine. in essence, determinism here specifies being able to do only one operation at a time, in non-determinism you perform correct operation at every instant without searching through possibilities. in reality, non-deterministic machines aren\\u2019t possible. but as we said earlier, every non-deterministic turing machine can be converted into a deterministic turing machine with time penalty.\"),mdx(\"h3\",o({},{id:\"complexity-classes\"}),mdx(\"a\",o({parentName:\"h3\"},{href:\"#complexity-classes\",className:\"anchor\"}),mdx(\"span\",o({parentName:\"a\"},{className:\"icon icon-link\"}))),\"Complexity classes\"),mdx(\"p\",null,\"moving on,\"),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"P\"),\" is the set of all problems that can be solved in polynomial time ( at most \",mdx(\"strong\",{parentName:\"p\"},\"N^k\"),\") on a deterministic turing machine where, N is the length of input, k is a constant.\"),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" is the set of all problems that can be solved in polynomial time ( at most \",mdx(\"strong\",{parentName:\"p\"},\"N^k\"),\") on a non-deterministic turing machine.\"),mdx(\"p\",null,\"key thing to note here, is that every \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" class problems can be solved in exponential time at most ( at most \",mdx(\"strong\",{parentName:\"p\"},\"2^(N^k)\"),\" ) time on a deterministic turing machine.\"),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"EXPTIME\"),\" is the set of all problems that can be solved in exponential time ( at most \",mdx(\"strong\",{parentName:\"p\"},\"2^(N^k)\"),\") on a deterministic turing machine.so, \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" \\u2286 \",mdx(\"strong\",{parentName:\"p\"},\"EXPTIME\"),\" \"),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"NP-complete\"),\" is the set of \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" problems which can be converted to every other \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" problem can be in a polynomial time penalty. If we want to prove one \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" problem as \",mdx(\"strong\",{parentName:\"p\"},\"NP-complete\"),\", we need not to prove every \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" problem being reduceable to that problem we can just prove that \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" problem can reduced into \",mdx(\"strong\",{parentName:\"p\"},\"NP-complete\"),\". Note that above, I used convertible, reduceable interchangeably.\"),mdx(\"p\",null,\"the hierarchy,\"),mdx(\"img\",{alt:\"P vs NP\",src:\"/static/images/pvsnp-intro/pvsnp.png\",width:1e3,height:600}),mdx(\"p\",null,\"there are also, other complexity classes like \",mdx(\"strong\",{parentName:\"p\"},\"NP-Hard\"),\" ( problem set to which every \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" problem can be reduced to whether \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" or not ), \",mdx(\"strong\",{parentName:\"p\"},\"PSPACE\"),\" ( analogous to \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\" in space ), \",mdx(\"strong\",{parentName:\"p\"},\"NPSPACE\"),\" ( analogous to \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" in space ), before defined \",mdx(\"strong\",{parentName:\"p\"},\"EXPTIME\"),\" ( \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" \\u2286 \",mdx(\"strong\",{parentName:\"p\"},\"EXPTIME\"),\" ), \",mdx(\"strong\",{parentName:\"p\"},\"NEXPTIME\"),\" ( analogous to \",mdx(\"strong\",{parentName:\"p\"},\"EXPTIME\"),\" for \",mdx(\"strong\",{parentName:\"p\"},\"NDTM\"),\" ), etc. but we don\\u2019t need them to introduce \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\" vs \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\".\"),mdx(\"p\",null,\"One Important thing to note, is even though \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" problems require exponential time to solve, they require only polynomial time to be verified. i.e, we can think \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\" class problems are easier to solve, easier to verify and \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" problems are harder to solve but easier to verify. \"),mdx(\"p\",null,\"Even though we aren\\u2019t able to prove \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\" vs \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" \"),mdx(\"p\",null,\"But with time hierarchy theorem,  we proved that, \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\"\\xA0\\u228A\\xA0\",mdx(\"strong\",{parentName:\"p\"},\"EXPTIME\"),\"\\xA0\\u228A\\xA0\",mdx(\"strong\",{parentName:\"p\"},\"2-EXP\"),\"\\xA0\\u228A ... and\\xA0\",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\"\\xA0\\u228A\\xA0\",mdx(\"strong\",{parentName:\"p\"},\"NEXPTIME\"),\"\\xA0\\u228A\\xA0\",mdx(\"strong\",{parentName:\"p\"},\"2-NEXP\"),\" \\u2026\"),mdx(\"p\",null,\"which can be helpful in solving \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\" vs \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\".\"),mdx(\"h3\",o({},{id:\"p-vs-np--the-holy-grail-of-computer-science-\"}),mdx(\"a\",o({parentName:\"h3\"},{href:\"#p-vs-np--the-holy-grail-of-computer-science-\",className:\"anchor\"}),mdx(\"span\",o({parentName:\"a\"},{className:\"icon icon-link\"}))),\"P vs NP ( the holy grail of computer science )\"),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"P\"),\" vs \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" is about figuring out whether \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\" = \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" or \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\" \\u2260 \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\". It\\u2019s is not just a mathematical problem but a philosophical one, \\u201CIs finding solutions harder than verifying them?\\u201D ( since \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\" class problems can be solved easier, \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" class problem are verified easier ).\"),mdx(\"p\",null,\"we might think intuitively, \\u201Cfinding solutions is harder than verifying solutions\\u201D like \\u201Cwriting a great poem should be harder than checking a great poem\\u201D. Even the famous physicist Feynman had trouble even being convinced that \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\" vs. \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" was an open problem!\"),mdx(\"p\",null,\"Because, All \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" problems require brute-force search ( searching all possible states for solution ) which results in the exponential time requirement. So to believe \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\" = \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\", we need to assume there is a general efficient way to solve every \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" problem. which is also a hard thing to assume against our Intuition.\"),mdx(\"p\",null,\"we generally believe the conjecture that \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\" \\u2260 \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" but It\\u2019s very HARD to prove it!!\"),mdx(\"p\",null,\"because, \\u201CA fundamental challenge when proving \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\" \\u2260 \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" is that, we have to separate \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" problems that are actually HARD from the problems that just look HARD or used to be assumed HARD\\u201D. problems like primality testing, DNA sequencing which were assumed to be \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" are now in \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\". the proofs that tried to prove, \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\" \\u2260 \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" can be rejected with this simple reason. as If we were to believe they work, then these polynomial reducible problems shouldn\\u2019t exist in the first place!\"),mdx(\"p\",null,\"We can however reduce scope to make our proof more stable, here \",mdx(\"strong\",{parentName:\"p\"},\"NP-complete\"),\" comes into picture. remember that any \",mdx(\"strong\",{parentName:\"p\"},\"NP-complete\"),\" problem can be converted into any \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" class problem. so, If we\\u2019re able to prove one \",mdx(\"strong\",{parentName:\"p\"},\"NP-complete\"),\" problem is equal to (or) not equal to \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\". we prove all problems of \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" are equal to (or) not equal to \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\".\"),mdx(\"p\",null,\"Repercussions of proving \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\" = \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" are massive, If \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\" = \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" many other complexity classes fall into \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\" as well like \",mdx(\"strong\",{parentName:\"p\"},\"co-NP\"),\",  \",mdx(\"strong\",{parentName:\"p\"},\"\\u03A0k P\"),\", \",mdx(\"strong\",{parentName:\"p\"},\"\\u03A3k P\"),\".\"),mdx(\"p\",null,\"with \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\" = \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\", \"),mdx(\"p\",null,\"any reasonable length mathematical proof can be found efficiently by an algorithm! ( because even though in polynomial \",mdx(\"strong\",{parentName:\"p\"},\"N^k\"),\", if the k is big It would be inefficient ). \"),mdx(\"p\",null,\"the idea that such problem is in \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" was actually pointed out by Kurt Godel in his 1956  letter to von neumann. he wrote, \\u201CConsider the problem of deciding whether a mathematical statement S has a proof in F with n symbols or fewer. we could always just program a computer to search through all \",mdx(\"strong\",{parentName:\"p\"},\"2^n\"),\" possible bit-strings with n symbols, and check whether any of them encodes a valid F-proof of S.\\u201D\"),mdx(\"p\",null,\"Godel also pointed out, \\u201Cit\\u2019s far from obvious how to prove that there isn\\u2019t a muchbetter approach: an approach that would avoid brute-force search, and find proofs of size n in time polynomial in n\\u201D. essentially discussing, proving \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\" \\u2260 \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" is HARD. the formal conjecture of \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\" vs \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" was formulated by cook in his 1971 paper.\"),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"P\"),\" = \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\" will also mean AI would be perfect as we can simply search large tree of possibilities in polynomial time. VLSI designers can design optimum circuits with minimum power requirements. any scientist can obtain the simplest theory that explains his/her experimental data, by Occam\\u2019s razor this is supposed to be the correct one! \"),mdx(\"p\",null,\"as said earlier in summary, \\u201CAny problem whose solution that can be verified easily, can be produced approximately that much easily\\u201D.\"),mdx(\"p\",null,\"It may also rule out the need of randomized algorithms, stochasticity principle as the gains will be negligible.\"),mdx(\"p\",null,\"On the other hand, all our cryptographic algorithms are designed with the assumption of existence of one-way functions which in turn assumes \",mdx(\"strong\",{parentName:\"p\"},\"P\"),\" \\u2260 \",mdx(\"strong\",{parentName:\"p\"},\"NP\"),\". so, there can be trivial decoding algorithms for every cryptographic algorithm, causing vulnerability to our security, privacy, data integrity.\"),mdx(\"p\",null,\"so, this is the explanation I felt sufficient for intuitively understanding complexity. because, I saw even experienced people having confusion over these ( cough cough tutorialspoint guy ).\"),mdx(\"p\",null,\"the main intention of writing this article, is to introduce these concepts intuitively to wider audience and to give motivation to CS students that they\\u2019re doing something really fundamental than just programming stuff. sadly, I was introduced to these concepts just before couple of months in my final year of Btech. had I been introduced to these earlier, It might\\u2019ve had significant impact in my formative years of undergraduation. which I hope happens to someone else. remember to get away from your engineering lens to a scientist lens once in a while. \"),mdx(\"p\",null,\"an engineer will accept the rules they\\u2019re given and try to solve problems with those rules, a scientist will question the rules itself. a mechanical engineer may design machines without realizing that forces are illusion but a physicist would realize that. similarly, a software engineer will develop algorithms without realizing the underlying assumptions.\"),mdx(\"p\",null,\"there are potential things that I missed (or) trivialized above for better understanding. as I\\u2019m fairly inexperienced, if there\\u2019re any errors above feel free to point out by my twitter handle. \"),mdx(\"h3\",o({},{id:\"references\"}),mdx(\"a\",o({parentName:\"h3\"},{href:\"#references\",className:\"anchor\"}),mdx(\"span\",o({parentName:\"a\"},{className:\"icon icon-link\"}))),\"References:\"),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"Introduction to the theory of computation - M Sipser\"),mdx(\"li\",{parentName:\"ol\"},\"The history and status of P versus NP Question - M Sipser\"),mdx(\"li\",{parentName:\"ol\"},\"Computational complexity a modern approach - S Arora, B Barak\"),mdx(\"li\",{parentName:\"ol\"},\"The nature of computation - C Moore, S Mertens\"),mdx(\"li\",{parentName:\"ol\"},\"What can be computed? - J MacCormick\"),mdx(\"li\",{parentName:\"ol\"},\"Why Philosophers Should Care About Computational Complexity  - S Aaronson\"),mdx(\"li\",{parentName:\"ol\"},\"Quantum computing since democritus - S Aaronson\"),mdx(\"li\",{parentName:\"ol\"},\"Automata, Computability, and Complexity, MIT 2011 - S Aaronson\")))}MDXContent.isMDXComponent=!0;\n","scope":{}},"tweetIDs":[],"frontMatter":{"wordCount":1930,"readingTime":{"text":"10 min read","minutes":9.595,"time":575700,"words":1919},"slug":"p-vs-np,logic-and-philosophy-behind-computation","title":"P vs NP, Logic and Philosophy Behind Computation","publishedAt":"2021-06-18","summary":"Intuition and foundational philosophy of computation","image":"/static/images/pvsnp-intro/banner.png"},"tweets":[]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"p-vs-np,logic-and-philosophy-behind-computation"},"buildId":"ZhQp9bG5xssvBTPKsy9hK","isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-189c53927ffd3caf09c3.js" async=""></script><script src="/_next/static/chunks/main-b53ad54fde926f8ee4c7.js" async=""></script><script src="/_next/static/chunks/pages/_app-d9d931a11f6f217e030b.js" async=""></script><script src="/_next/static/chunks/562-cf4ef120cfac2df7f9ea.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-a7fcfddf24d7867ca73a.js" async=""></script><script src="/_next/static/ZhQp9bG5xssvBTPKsy9hK/_buildManifest.js" async=""></script><script src="/_next/static/ZhQp9bG5xssvBTPKsy9hK/_ssgManifest.js" async=""></script></body></html>